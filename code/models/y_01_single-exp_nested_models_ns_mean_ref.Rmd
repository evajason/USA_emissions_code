---
title: "Nonlinear models with natural spline"
author: "Yanelli Nunez"
date: "12/15/2021"
output:
 html_document:
    toc: TRUE
    toc_float: TRUE
    code_folding: hide
editor_options: 
  chunk_output_type: console
---

Objective:  

Automate the process of running national-level models.

I am running the models with a natural spline but setting the reference number at zero. Also, note that the models are adjusted for epa geographic region. 

- NOx from transport 
- NH3 from agriculture 
- SO2 from energy --> Selected 95th percentile of data which excluded extreme values
- NOx from energy --> Selected 95th percentile of data which excluded extreme values
- SO2 from industry  --> I removed the observations with "infinity" emissions with was a total of 5 per year and replace the NaN with zero
- OC from residential
- NOx from commercial

```{r include=FALSE}

rm(list=ls())

# 1a Declare root directory
project.folder <- paste0(print(here::here()),'/')

# add folder locations
source(paste0(project.folder,'0_00_create_folder_structure.R'))

# add file locations
source(paste0(file.locations.folder,'external_file_locations.R'))

# load packages
source(paste0(packages.folder,'packages_to_load.R'))

# load functions
source(paste0(code.folder, 'models/functions.R'))

# load data
source(paste0(code.folder, 'data_loading.R'))

```

## i. View Data Summaries 
```{r}
summary(data_master)
summary(so2_energy)
```


## 1. Prep function arguments

I created dataset with the arguments I need to run all of the models which I then split into the following:

Nonlinear_models: 
1) economic variables --> all economic variables have a non-linear relationship with the outcome

2) racial variables --> most racial variables are non-linear
    2a. Asian, Hispanic, Native adjusted for s(perc_white)
    2b. Black adjusted for ns(perc_white, df = 4)

Linear_models:

1) racial variables --> only racial variables have linear associations
    2a. Asian, Hispanic, Native adjusted for s(perc_white)
    2b. Black adjusted for ns(perc_white, df = 4)

Notes: 
- I had to split the nonlinear models intor economic and racial because the racial models are adjusted for percent white but the economic models are not, so I couldn't run them in the same batch with the workflow i have.
- I also run the models for percent black and percent white separately because in this case we include both variables with a natural spline (for the other racial models we adjust using s(perc_white))

```{r}

### dataset containing the arguments for all models we need to run

models_to_make = c("Ns(perc_unemp, df = 4, ref = 5.4)",  # we use the mean as the reference for the nonlinear curves 
             "Ns(perc_pvert, df = 4, ref = 16.45)",
             "Ns(fam_incom_adjs, df = 4, ref = 55047)",
             "Ns(propty_val_adjs, df = 4, ref = 93712)",
             "Ns(perc_white, df = 4, ref = 87.58)",
             "Ns(perc_black, df = 4, ref = 8.81)",
             "Ns(perc_asian, df = 4, ref = 1.08)",
             "Ns(perc_nativ, df = 4, ref = 1.29)",
             "Ns(perc_hisp_org, df = 4, ref = 4.42)") %>%
  as.data.frame() %>%
   rename(., ns_arg = .) %>%
  mutate(exposure =  c("perc_unemp", 
                  "perc_pvert",
                  "fam_incom_adjs",
                  "propty_val_adjs",
                  "perc_white",
                  "perc_black",
                  "perc_asian",
                  "perc_nativ",
                  "perc_hisp_org")) %>%
  as.data.frame() %>%
  mutate(x_label = c("% Unemployment", "% Poverty", "Median Family Income ($1000)", "Median Propty Value ($1000)", "% White", "% Black", "% Asian", "% American Native", "% Hispanic")) %>% # x label for ggplot
  mutate(color = dplyr::if_else(exposure %in% c("perc_unemp", "perc_pvert", "fam_incom_adjs", "propty_val_adjs"), "#69b3a2", "#386cb0")) %>% # specify ggplot color based on exposure variable
 mutate(freq=7) %>%
  map_df(., rep, .$freq) %>%
mutate(id = rep(1:7, length.out = n())) %>%
mutate(outcome = case_when(id == 1 ~ 'so2_energy_relat_chg',  ## add outcome column
                           id == 2 ~ 'nox_energy_relat_chg', 
                           id == 3 ~ 'so2_indus_relat_chg', 
                           id == 4 ~ 'nox_trans_relat_chg', 
                           id == 5 ~ 'nh3_agric_relat_chg', 
                           id == 6 ~ 'oc_resid_relat_chg', 
                           id == 7 ~ 'nox_commer_relat_chg')) %>%
  dplyr::select(-freq, -id) %>%
   mutate(data_spf = if_else(outcome == "so2_energy_relat_chg", "so2_energy",
                      if_else(outcome == "so2_indus_relat_chg", "so2_inds",
                        if_else(outcome == "nox_energy_relat_chg", "nox_energy", "data_master")))) %>%
  arrange(outcome)
  

### dataset with the arguments for the NON-LINEAR MODELS  
  models_to_make_nonlinear <- models_to_make %>%
  dplyr::filter(!(outcome == "so2_energy_relat_chg" & exposure %in% c("perc_asian", "perc_hisp_org"))) %>%
  dplyr::filter(!(outcome == "nox_energy_relat_chg" & exposure %in% c("perc_white", "perc_black", "perc_asian", "perc_nativ"))) %>%
  dplyr::filter(!(outcome == "so2_indus_relat_chg" & exposure == "perc_black")) %>%
  dplyr::filter(!(outcome == "nox_trans_relat_chg" & exposure == "perc_nativ")) %>%
  dplyr::filter(!(outcome == "nh3_agric_relat_chg" & exposure == "perc_nativ")) %>%
  dplyr::filter(!(outcome == "oc_resid_relat_chg" & exposure == "perc_black")) 
  
  
### dataset with arguments for the NON-LINEAR models: economic variables & hispanic
  models_to_make_nonlinear_eco <- models_to_make_nonlinear %>%
    filter(exposure %in% c("perc_unemp", "perc_pvert", "fam_incom_adjs", "propty_val_adjs", "perc_hisp_org")) 
    

### dataset with arguments for the NON-LINEAR models: asian and american native (adjusted for perc_white)
### 1) includes asian, native, and hispanic 
  models_to_make_nonlinear_race <- models_to_make_nonlinear %>%
    filter(exposure %in% c("perc_asian", "perc_nativ"))
  
## 2) includes Black 
  models_to_make_nonlinear_blk_wht <- models_to_make %>%
    filter(exposure == "perc_black")
  
  
### dataset with the arguments for the LINEAR MODELS 
  models_to_make_linear <- models_to_make %>%
  dplyr::filter(outcome == "so2_energy_relat_chg" & exposure %in% c("perc_asian", "perc_hisp_org") |
                outcome == "nox_energy_relat_chg" & exposure %in% c("perc_white", "perc_black", "perc_asian", "perc_nativ") |
                outcome == "so2_indus_relat_chg" & exposure == "perc_black" |
                outcome == "nox_trans_relat_chg" & exposure == "perc_nativ" |
                outcome == "nh3_agric_relat_chg" & exposure == "perc_nativ" |
                outcome == "oc_resid_relat_chg" & exposure == "perc_black") %>%
    mutate(basis_name = case_when(exposure == "perc_white" & data_spf == "nox_energy" ~ 'cb_nox_energy_white',
                             exposure == "perc_black" & data_spf == "nox_energy" ~ 'cb_nox_energy_black',
                             exposure == "perc_black" & data_spf == "so2_inds" ~ 'cb_so2_inds_black',
                             exposure == "perc_black" & data_spf == "data_master" ~ 'cb_data_master_black',
                             exposure == "perc_asian" & data_spf == "so2_energy" ~ 'cb_so2_energy_asian',
                             exposure == "perc_asian" & data_spf == "nox_energy" ~ 'cb_nox_energy_asian',
                             exposure == "perc_nativ" & data_spf == "nox_energy" ~ 'cb_nox_energy_nativ',
                             exposure == "perc_nativ" & data_spf == "data_master" ~ 'cb_data_master_nativ',
                             exposure == "perc_hisp_org" & data_spf == "so2_energy" ~ 'cb_so2_energy_hisp')) %>%
    mutate(pred_name = gsub("cb", "pred", basis_name)) 
  
  
  ### dataset with arguments for the LINEAR racial models
### 1) includes asian, native, and hispanic 
  models_to_make_linear_race <- models_to_make_linear %>%
    filter(exposure %in% c("perc_asian", "perc_nativ"))
  
## 2) includes Black 
  models_to_make_linear_blk_wht <- models_to_make_linear %>%
    filter(exposure == "perc_black")
  


```



## 2. Progress bar 

Parallelize: runs the iterations in parallel across multiple cores to increase speed
You computer has multiple processing cores but it only uses one to ran your R code. Paralizing the procesing means that you are telling your computer to run different portions of your code simultaneously in multiple cores. This results in an overall faster processing

```{r}

#### set up a progress bar
pb <- txtProgressBar(min = 0, max = nrow(models_to_make), width = 25, style = 3)
progress <- function(p) setTxtProgressBar(pb, p)
opts <- list(progress=progress)

### code to paralized the processing among multiple cores
cores <- ceiling(parallel::detectCores() / 2) # use half of the available cores 
cluster <- snow::makeCluster(cores) 
doSNOW::registerDoSNOW(cluster)

```

## 3. Autoprocessing of NON-LINEAR models

- We using the foreach() function to loop our function over each row of the datasets definined in point 1.

### 3a. Nonlinear economic and hispanic models

This models are NOT adjusted for % white

```{r}

### run the foreach() loop (I am parallelizing this process to make it faster)
         
models_nonlin_eco <- foreach(i = iterators::icount(nrow(models_to_make_nonlinear_eco)), # iterate across rows
                             .options.snow=opts, # the progress bar being sent to each core
                             .packages=c("Epi", "magrittr", "dplyr", "janitor", "ggplot2"), # the packages being sent to each core
                             .export = ls(globalenv()),
                             .inorder = FALSE, # speeds up parallel programming
                             .combine = rbind) %dopar% { # if you doing parallel programming use %dopar% otherwise use %do%
  
  # make model i
  m <- run_model(data   = models_to_make_nonlinear_eco$data_spf[[i]],
                outcome = models_to_make_nonlinear_eco$outcome[[i]], 
               exposure = models_to_make_nonlinear_eco$ns_arg[[i]]) # the natural spline terms
  
  df <- models_to_make_nonlinear_eco[i,] %>% mutate(models = list(m))
  
  # make plot for model i (don't need to index by i since that was done in df above^)
 plot <- plot_nonlin(model = df$models[[1]], 
                     data = df$data_spf[[1]], 
                 exposure = df$exposure[[1]],
                   x_label = df$x_label[[1]],
                     color = df$color[[1]])
 
 df <- df %>% mutate(plots = list(plot)) %>%
  dplyr::select(-ns_arg, -color, -x_label) %>%
  arrange(outcome)
 
  
  # save our work
  df
  
}

# stop the parellel processing
snow::stopCluster(cluster)
close(pb)


# save list dataset 

saveRDS(models_nonlin_eco, paste0(yanelli_external, "results_updated/models_nonlin_eco_hisp.rds"))

```



### 3a. Nonlinear racial models

#### Asian & American Native 

These models are adjusted for % White

```{r}

### run the foreach() loop ( I am parallelizing this process to make it faster)
         
models_nonlin_race <- foreach(i = iterators::icount(nrow(models_to_make_nonlinear_race)), # iterate across rows
                             .options.snow=opts, # the progress bar being sent to each core
                             .packages=c("Epi", "magrittr", "dplyr", "janitor", "ggplot2"), # the packages being sent to each core
                             .export = ls(globalenv()),
                             .inorder = FALSE, # speeds up parallel programming
                             .combine = rbind) %dopar% { # if you doing parallel programming use %dopar% otherwise use %do%
  
  # make model i
  m <- run_model_race(data   = models_to_make_nonlinear_race$data_spf[[i]],
                     outcome = models_to_make_nonlinear_race$outcome[[i]], 
                    exposure = models_to_make_nonlinear_race$ns_arg[[i]]) # the natural spline terms
  
  df <- models_to_make_nonlinear_race[i,] %>% mutate(models = list(m))
  
  # make plot for model i (don't need to index by i since that was done in df above^)
 plot <- plot_nonlin(model = df$models[[1]], 
                     data = df$data_spf[[1]], 
                 exposure = df$exposure[[1]],
                   x_label = df$x_label[[1]],
                     color = df$color[[1]])
 
 df <- df %>% mutate(plots = list(plot)) %>%
  dplyr::select(-ns_arg, -color, -x_label) %>%
   arrange(outcome)
  
  # save our work
  df
  
}

# stop the parellel processing
snow::stopCluster(cluster)
close(pb)


# save list dataset 

saveRDS(models_nonlin_race, paste0(yanelli_external, "results_updated/models_nonlin_asian_an.rds"))

```

#### Black & White 

```{r}

### run the foreach() loop ( I am parallelizing this process to make it faster)
         
models_nonlin_blk_wht <- foreach(i = iterators::icount(nrow(models_to_make_nonlinear_blk_wht)), # iterate across rows
                             .options.snow=opts, # the progress bar being sent to each core
                             .packages=c("Epi", "magrittr", "dplyr", "janitor", "ggplot2"), # the packages being sent to each core
                             .export = ls(globalenv()),
                             .inorder = FALSE, # speeds up parallel programming
                             .combine = rbind) %dopar% { # if you doing parallel programming use %dopar% otherwise use %do%
  
  # make model i
  m <- run_model_blk(data   = models_to_make_nonlinear_blk_wht$data_spf[[i]],
                     outcome = models_to_make_nonlinear_blk_wht$outcome[[i]], 
                    exposure = models_to_make_nonlinear_blk_wht$ns_arg[[i]]) # the natural spline terms
  
  df <- models_to_make_nonlinear_blk_wht[i,] %>% mutate(models = list(m))
  
  # make plot for model i (don't need to index by i since that was done in df above^)
 plot <- plot_nonlin(model = df$models[[1]], 
                     data = df$data_spf[[1]], 
                 exposure = df$exposure[[1]],
                   x_label = df$x_label[[1]],
                     color = df$color[[1]])
 
 df <- df %>% mutate(plots = list(plot)) 
 
  # make plot for White for model i (don't need to index by i since that was done in df above^)
 plot_white <- plot_nonlin_white(model = df$models[[1]], 
                     data = df$data_spf[[1]], 
                     color = df$color[[1]])
 
 df <- df %>% mutate(plots_white = list(plot_white)) %>%
  dplyr::select(-ns_arg, -color, -x_label)
  
  # save our work
  df
  
}

# stop the parellel processing
snow::stopCluster(cluster)
close(pb)


# save list dataset 

saveRDS(models_nonlin_blk_wht, paste0(yanelli_external, "results_updated/models_nonlin_blk_wht.rds"))

```

## 4. Autoprocessing of LINEAR models

 The associations below are linear:

1) SO2 from energy: 
-Asian
-Hispanic

2) NOx from energy:
-White
-Black
-Asian
-A. Native

3) SO2 from industry:
-Black

4) NOx from transport 
-American native 

5) NH3 from agriculture 
-American native

6) OC from residential
-Black

7) NOx from commercial
-all nonlinear terms

### 4a. Onebasis

```{r}
### run the foreach() loop to generate the onebasis 
         
linear_onebasis <- foreach(i = iterators::icount(nrow(models_to_make_linear)), # iterate across rows
                             #.options.snow=opts, # the progress bar being sent to each core
                             #.packages=c("Epi", "magrittr", "dplyr", "janitor", "ggplot2"), # the packages being sent to each core
                             #.export = ls(globalenv()),
                             #.inorder = FALSE, # speeds up parallel programming
                             .combine = rbind) %do% { # if you doing parallel programming use %dopar% otherwise use %do%
  
  # make basis
  b <- one_basis(data = models_to_make_linear$data_spf[[i]],
               exposure = models_to_make_linear$exposure[[i]])
  
   assign(models_to_make_linear$basis_name[[i]], b) 
  
}

remove(linear_onebasis) ## because each individual basis was individually save into the environment
remove(b) ## this is basically the last i which is also save with a specific name in the environment


```

### Models

#### Asian, American Native

This models are adjusted for % white

```{r}

### foreach() loop to run the models (If I parallelize the process, it gives an error...)

linear_models_race <- foreach(i = iterators::icount(nrow(models_to_make_linear_race)), # iterate across rows
                             .options.snow=opts, # the progress bar being sent to each core
                            # .packages=c("Epi", "magrittr", "dplyr", "janitor", "ggplot2"), #packages being sent to each core
                            # .export = ls(globalenv()),
                             .inorder = FALSE, # speeds up parallel programming
                             .combine = rbind) %do% { # if you doing parallel programing use %dopar% otherwise use %do%
  
  # make models
      m <- run_model_race(data = models_to_make_linear_race$data_spf[[i]],
                       outcome = models_to_make_linear_race$outcome[[i]],
                      exposure = models_to_make_linear_race$basis_name[[i]]) ## in this case use the onebasis as the exposure 
  
   df <- models_to_make_linear[i,] %>% mutate(models = list(m))
   

}

remove(m)

# stop the parellel processing
#snow::stopCluster(cluster)
#close(pb)

```

#### Hispanic 

SO2 from Energy 

```{r}

```

#### Black & White 

```{r}

### foreach() loop to run the models (If I parallelize the process, it gives an error...)

linear_models_blk_wht <- foreach(i = iterators::icount(nrow(models_to_make_linear_blk_wht)), # iterate across rows
                             .options.snow=opts, # the progress bar being sent to each core
                            # .packages=c("Epi", "magrittr", "dplyr", "janitor", "ggplot2"), #packages being sent to each core
                            # .export = ls(globalenv()),
                             .inorder = FALSE, # speeds up parallel programming
                             .combine = rbind) %do% { # if you doing parallel programing use %dopar% otherwise use %do%
  
  # make models
      m <- run_model(data = models_to_make_linear_blk_wht$data_spf[[i]],
                  outcome = models_to_make_linear_blk_wht$outcome[[i]],
                 exposure = models_to_make_linear_blk_wht$basis_name[[i]]) ## in this case use the onebasis as the exposure
  
   df <- models_to_make_linear[i,] %>% mutate(models = list(m))
   

}

remove(m)

# stop the parellel processing
#snow::stopCluster(cluster)
#close(pb)

```


### 4b. Crosspred

I couldn't make crosspred work by referencing the basis so I couldn't run the crosspred portion inside foreach(). Thus, I have to do it here individually for each model :( (total of 10)

```{r}

pred_nox_energy_white <- crosspred(
  #basis = get(models_to_make_linear$basis_name[1]), #### the basis argument isn't working using indexing :(
  basis = cb_nox_energy_white, #### the basis argument isn't working using indexing :(
  model = linear_models$models[[1]], 
  at = get(linear_models$data_spf[[1]])[, models_to_make_linear$exposure[[1]]], 
  cen = (mean(get(linear_models$data_spf[[1]])[, linear_models$exposure[[1]]])))

pred_nox_energy_black <- crosspred(
  basis = cb_nox_energy_black, #### the basis argument isn't working using indexing :(
  model = linear_models$models[[2]], 
  at = get(linear_models$data_spf[[2]])[, models_to_make_linear$exposure[[2]]], 
  cen = (mean(get(linear_models$data_spf[[2]])[, linear_models$exposure[[2]]])))

pred_so2_inds_black <- crosspred(
  basis = cb_so2_inds_black, #### the basis argument isn't working using indexing :(
  model = linear_models$models[[3]], 
  at = get(linear_models$data_spf[[3]])[, models_to_make_linear$exposure[[3]]], 
  cen = (mean(get(linear_models$data_spf[[3]])[, linear_models$exposure[[3]]])))

pred_data_master_black <- crosspred(
  basis = cb_data_master_black, #### the basis argument isn't working using indexing :(
  model = linear_models$models[[4]], 
  at = get(linear_models$data_spf[[4]])[, models_to_make_linear$exposure[[4]]], 
  cen = (mean(get(linear_models$data_spf[[4]])[, linear_models$exposure[[4]]])))

pred_so2_energy_asian <- crosspred(
  basis = cb_so2_energy_asian, #### the basis argument isn't working using indexing :(
  model = linear_models$models[[5]], 
  at = get(linear_models$data_spf[[5]])[, models_to_make_linear$exposure[[5]]], 
  cen = (mean(get(linear_models$data_spf[[5]])[, linear_models$exposure[[5]]])))

pred_nox_energy_asian <- crosspred(
  basis = cb_nox_energy_asian, #### the basis argument isn't working using indexing :(
  model = linear_models$models[[6]], 
  at = get(linear_models$data_spf[[6]])[, models_to_make_linear$exposure[[6]]], 
  cen = (mean(get(linear_models$data_spf[[6]])[, linear_models$exposure[[6]]])))

pred_nox_energy_nativ <- crosspred(
  basis = cb_nox_energy_nativ, #### the basis argument isn't working using indexing :(
  model = linear_models$models[[7]], 
  at = get(linear_models$data_spf[[7]])[, models_to_make_linear$exposure[[7]]], 
  cen = (mean(get(linear_models$data_spf[[7]])[, linear_models$exposure[[7]]])))

pred_data_master_nativ <- crosspred(
  basis = cb_data_master_nativ, #### the basis argument isn't working using indexing :(
  model = linear_models$models[[8]], 
  at = get(linear_models$data_spf[[8]])[, models_to_make_linear$exposure[[8]]], 
  cen = (mean(get(linear_models$data_spf[[8]])[, linear_models$exposure[[8]]])))

pred_data_master_nativ <- crosspred(
  basis = cb_data_master_nativ, #### the basis argument isn't working using indexing :(
  model = linear_models$models[[9]], 
  at = get(linear_models$data_spf[[9]])[, models_to_make_linear$exposure[[9]]], 
  cen = (mean(get(linear_models$data_spf[[9]])[, linear_models$exposure[[9]]])))

pred_so2_energy_hisp <- crosspred(
  basis = cb_so2_energy_hisp, #### the basis argument isn't working using indexing :(
  model = linear_models$models[[10]], 
  at = get(linear_models$data_spf[[10]])[, models_to_make_linear$exposure[[10]]], 
  cen = (mean(get(linear_models$data_spf[[10]])[, linear_models$exposure[[10]]])))

```

### 4c. Plot linear models 

```{r}

linear_plots <- foreach(i = iterators::icount(nrow(linear_models)), # iterate across rows
                             .options.snow=opts, # the progress bar being sent to each core
                             .packages=c("Epi", "magrittr", "dplyr", "janitor", "ggplot2"), # packages being sent to each core
                             .export = ls(globalenv()),
                             .inorder = FALSE, # speeds up parallel programming
                             .combine = rbind) %dopar% { # if you doing parallel programing use %dopar% otherwise use %do%
  
  # crosspred 
      ##pred <- crosspred(
      #              basis = linear_models$basis_name[[i]], #### the basis argument isn't working using indexing :(
      #              model = linear_models$models[[i]], 
      #                 at = get(linear_models$data_spf[[i]])[, linear_models$exposure[[i]]], 
      #                cen = (mean(get(linear_models$data_spf[[i]])[, linear_models$exposure[[i]]])))                         
     
      #df <- linear_models[i,] %>% mutate(predic_est = list(pred))
      
  # plot models                            
      p <- plot_linear(pred_est = linear_models$pred_name[[i]],
                        x_label = linear_models$x_label[[i]],
                          color = linear_models$color[[i]]) ## in this case use the onebasis as the exposure
  
  
  df <- linear_models[i,] %>% mutate(plots = list(p)) %>%
        dplyr::select(-ns_arg, -color, -x_label, -basis_name, -pred_name)
   
   df
}

remove(p)

# stop the parellel processing
snow::stopCluster(cluster)
close(pb)

```


## 5. Save file
```{r}

saveRDS(linear_plots, paste0(yanelli_external, "results/models_linear.rds"))


```

```{r}
linear_plots$plots[[1]]

summary(linear_plots$models[[1]])
```

